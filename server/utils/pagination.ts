import {
  GovUkPagination,
  GovUkPaginationItem,
  GovUkPaginationNextItem,
  GovUkPaginationPreviousItem,
} from '../types/govUk/pagination'

const createNextItem = (
  currentPage: number,
  pageCount: number,
  hrefPrefix: string,
): GovUkPaginationNextItem | undefined => {
  if (currentPage < pageCount) {
    return {
      href: `${hrefPrefix}page=${currentPage + 1}`,
    }
  }

  return undefined
}

const createPrevItem = (currentPage: number, hrefPrefix: string): GovUkPaginationPreviousItem | undefined => {
  if (currentPage !== 1) {
    return {
      href: `${hrefPrefix}page=${currentPage - 1}`,
    }
  }

  return undefined
}

const createItem = (item: number, hrefPrefix: string, current: boolean = false): GovUkPaginationItem => {
  if (current) {
    return {
      number: item.toString(),
      href: `${hrefPrefix}page=${item}`,
      current: true,
    }
  }

  return { number: item.toString(), href: `${hrefPrefix}page=${item}` }
}

const createItemsPrefix = (previousPage: number, hrefPrefix: string): Array<GovUkPaginationItem> => {
  const offset = previousPage - 1
  const firstPage = createItem(1, hrefPrefix)
  const secondPage = createItem(2, hrefPrefix)

  // First page will be generated by createItemsBody
  if (offset === 0) {
    return []
  }

  // The first page is always shown
  if (offset === 1) {
    return [firstPage]
  }

  // If only 1 page would be hidden by an ellipsis, show that page
  if (offset === 2) {
    return [firstPage, secondPage]
  }

  // If > 1 hidden, use ellipses (…) to show skipped pages
  return [firstPage, { ellipsis: true }]
}

const createItemsSuffix = (nextPage: number, pageCount: number, hrefPrefix: string): Array<GovUkPaginationItem> => {
  const offset = pageCount - nextPage
  const lastPage = createItem(pageCount, hrefPrefix)
  const secondLastPage = createItem(pageCount - 1, hrefPrefix)

  // Last page will be generated by createItemsBody
  if (offset === 0) {
    return []
  }

  // The last page is always shown
  if (offset === 1) {
    return [lastPage]
  }

  // If only 1 page would be hidden by an ellipsis, show that page
  if (offset === 2) {
    return [secondLastPage, lastPage]
  }

  // If > 1 hidden, use ellipses (…) to show skipped pages
  return [{ ellipsis: true }, lastPage]
}

const createItemsBody = (
  previousPage: number,
  nextPage: number,
  currentPage: number,
  hrefPrefix: string,
): Array<GovUkPaginationItem> => {
  return Array.from({ length: nextPage - previousPage + 1 }, (_, i) => i + previousPage).map(item =>
    createItem(item, hrefPrefix, item === currentPage),
  )
}

const createItems = (currentPage: number, pageCount: number, hrefPrefix: string): Array<GovUkPaginationItem> => {
  const previousPage = Math.max(1, currentPage - 1)
  const nextPage = Math.min(currentPage + 1, pageCount)

  return [
    ...createItemsPrefix(previousPage, hrefPrefix),
    ...createItemsBody(previousPage, nextPage, currentPage, hrefPrefix),
    ...createItemsSuffix(nextPage, pageCount, hrefPrefix),
  ]
}

const sanitiseHrefPrefix = (hrefPrefix: string) => {
  if (hrefPrefix.includes('?')) {
    const lastCharacter = hrefPrefix.at(hrefPrefix.length - 1)

    if (lastCharacter !== '?' && lastCharacter !== '&') {
      return `${hrefPrefix}&`
    }

    return hrefPrefix
  }

  return `${hrefPrefix}?`
}

const pagination = (currentPage: number, pageCount: number, hrefPrefix: string): GovUkPagination => {
  const prefix = sanitiseHrefPrefix(hrefPrefix)

  return {
    items: createItems(currentPage, pageCount, prefix),
    next: createNextItem(currentPage, pageCount, prefix),
    previous: createPrevItem(currentPage, prefix),
  }
}

export default pagination
